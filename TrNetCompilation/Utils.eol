
operation abs(a){
	if (a < 0.0d){
		return -a;
	} else {
		return a;
	}
}

operation computeTransformationCost(trnetmodel){
	// global maps:
	var nodePattern2AttributeDistinctValues = new Map;
	
	var totalCost = 0.0d;
	
	if (findAllImplicitOperators(trnetmodel).isEmpty()){
		initializeNodePattern2AttributeDistinctValues(nodePattern2AttributeDistinctValues);
		clearAllExpectedSizes();
		estimateExpectedSizesInStartPatterns(nodePattern2AttributeDistinctValues);
		generateExpectedSizesFromStartPatterns(nodePattern2AttributeDistinctValues);
		
		for (pat in trnetmodel.patterns) { 
			totalCost = totalCost + pat.expected_size;
		}
	}
	
	return totalCost;
}

operation generateExpectedSizesFromStartPatterns(nodePattern2AttributeDistinctValues){
	var changesHaveBeenMade = true;
	
	while (changesHaveBeenMade) {
		changesHaveBeenMade = false;
		for (pattern in getAllSuitedPatterns()){
			
			("Setting size of pattern " + pattern + " ...").println;
			computeExpectedSize(pattern, nodePattern2AttributeDistinctValues);
			changesHaveBeenMade = true;
			
			("Expected size of pattern " + pattern + " set!").println;
		}
	}
}

operation computeExpectedSize(pattern, nodePattern2AttributeDistinctValues) {
	for (operator in getIncomingOperatorsSet(pattern)){
		if (operator.isKindOf(VisualModel!External)){
			throw("Unexpected unfilled pattern found: " + pattern);
		} else if (operator.isKindOf(VisualModel!Combinator)){
			if (operatorHasOneOperand(operator)){
				if (operator.operands.first.isKindOf(VisualModel!AntiOperand)) {
					throw ("Error: Anti Operands have to be combined with some other pattern. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!AnyOperand)){
					fillStatisticsSingleCombinator(pattern , operator, nodePattern2AttributeDistinctValues);
				} else if (operator.operands.first.isKindOf(VisualModel!OptionalOperand)){
					throw ("Error: Operand not supported yet. In " + operator.operands.first);
				} else {
					throw("Unexpected kind of operand " + operator.operands.first);
				}
			} else if (operatorHasTwoOperands(operator)) {
				
				// AnyOperand combined with all
				if (operator.operands.first.isKindOf(VisualModel!AnyOperand) and operator.operands.last.isKindOf(VisualModel!AnyOperand)) {
					 fillStatisticsDoubleCombinator(pattern , operator, nodePattern2AttributeDistinctValues);
				} else if (operator.operands.first.isKindOf(VisualModel!AnyOperand) and operator.operands.last.isKindOf(VisualModel!AntiOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!AnyOperand) and operator.operands.last.isKindOf(VisualModel!OptionalOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				
				// SomeOperand combined with all
				} else if (operator.operands.first.isKindOf(VisualModel!SomeOperand) and operator.operands.last.isKindOf(VisualModel!AnyOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!SomeOperand) and operator.operands.last.isKindOf(VisualModel!SomeOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!SomeOperand) and operator.operands.last.isKindOf(VisualModel!AntiOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!SomeOperand) and operator.operands.last.isKindOf(VisualModel!OptionalOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				
				// AntiOperand combined with all
				} else if (operator.operands.first.isKindOf(VisualModel!AntiOperand) and operator.operands.last.isKindOf(VisualModel!AnyOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!AntiOperand) and operator.operands.last.isKindOf(VisualModel!SomeOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!AntiOperand) and operator.operands.last.isKindOf(VisualModel!AntiOperand)){
					throw ("Unexpected combination of operands in " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!AntiOperand) and operator.operands.last.isKindOf(VisualModel!OptionalOperand)){
					throw ("Unexpected combination of operands in " + operator);
				
				// OptionalOperand combined with all
				} else if (operator.operands.first.isKindOf(VisualModel!OptionalOperand) and operator.operands.last.isKindOf(VisualModel!AnyOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!OptionalOperand) and operator.operands.last.isKindOf(VisualModel!SomeOperand)){
					throw ("Error: feature not supported yet. In " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!OptionalOperand) and operator.operands.last.isKindOf(VisualModel!AntiOperand)){
					throw ("Unexpected combination of operands in " + operator);
				} else if (operator.operands.first.isKindOf(VisualModel!OptionalOperand) and operator.operands.last.isKindOf(VisualModel!OptionalOperand)){
					throw ("Unexpected combination of operands in " + operator);
				}
			} else {
				throw ("Error: Unexpected number of operands in operator " + operator);
			}
		} else {
			throw ("Error: Unexpected kind of operator in " + operator);
		}
	}
}

operation fillStatisticsDoubleCombinator(pattern , combinator, nodePattern2AttributeDistinctValues) {
	assert(operatorHasTwoOperands(combinator), "fillStatisticsDoubleCombinator with one operand in combinator " + combinator);
	
	var sourcePattern1 = combinator.operands.first.pattern;
	var sourcePattern2 = combinator.operands.last.pattern;
	
	/*
	We compute the selectivity of the operator simulating the join operation in both directions:
	first we take a tuple from the left operand, and estimate how many result it will produce we joined with the right operands
	and then we do the same for a tuple in the right operand.
	The result is the minimum between the two selectivities. If the vary, this means there will be tuples that do not join the other operands, 
	and hence, will not be apart of the final result. In this case we choose the estimate that gives the lowest selectivity.
	*/
	var selectivityJoinLeft2Right = computeSelectivityOperatorJoinConditions(combinator, sourcePattern1, sourcePattern2);
	var selectivityJoinRight2Left = computeSelectivityOperatorJoinConditions(combinator, sourcePattern2, sourcePattern1);
	// Remember that we have the lowest selectivity, means the highest selectivity denominator.
	var selectivityJoin = max(selectivityJoinLeft2Right, selectivityJoinRight2Left);
	
	("selectivityJoin: " + selectivityJoin).println();
	
	
	//("Selectivity join for " + sourcePattern1.id + " and " + sourcePattern2.id + " is " + selectivityJoinLeft2Right).println();
	//("Selectivity join for " + sourcePattern2.id + " and " + sourcePattern1.id + " is " + selectivityJoinRight2Left).println();
	
	
	// Now must take into account other possible operator conditions
	var selectivityOtherConditions = computeSelectivityOperatorConditions(combinator, nodePattern2AttributeDistinctValues);
	
	("selectivityOtherConditions: " + selectivityOtherConditions).println();
	
	var expectedNumberOfInstancesInPattern = (sourcePattern1.expected_size*sourcePattern2.expected_size)/(selectivityJoin*selectivityOtherConditions);
	
	("expectedNumberOfInstancesInPattern: " + expectedNumberOfInstancesInPattern).println();
	
	assert(expectedNumberOfInstancesInPattern>0.0, "expectedNumberOfInstancesInPattern>0.0 in fillStatisticsDoubleCombinator");
	
	var maxExpectedNumberOfInstancesInPattern = 1.0d;
	
	// Note that cannot be more distinct patterns than the combinations of all the node distinct patterns.
	// Althouthg this creates a circular dependency between the number of distinct values for a pattern and the number of distinct values for each node pattern, it
	// is easy to see that, if the number of distinct values in the pattern restricts the number of distinct values of some node pattern, 
	// this count here will have no effect. Note that the number of instances in the pattern will never lower below the values of the number of instances for each node pattern.
	for (nodePattern in pattern.nodes) {
		("Setting size of node " + nodePattern.id + " " + nodePattern + " ...").println;
		var nodePatternExpectedNumberOfDistinctValues = fillStatisticsDoubleCombinatorNodePattern(nodePattern, combinator, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues);
		assert(nodePatternExpectedNumberOfDistinctValues > 0.0, "nodePatternExpectedNumberOfDistinctValues > 0.0 in fillStatisticsDoubleCombinator");
		maxExpectedNumberOfInstancesInPattern = multiplySafe(maxExpectedNumberOfInstancesInPattern,nodePatternExpectedNumberOfDistinctValues);
		("nodePatternExpectedNumberOfDistinctValues: " + nodePatternExpectedNumberOfDistinctValues).println();
		("maxExpectedNumberOfInstancesInPattern: " + maxExpectedNumberOfInstancesInPattern).println();
		
		("Size of node " + nodePattern + " Set!").println;
	}
	
	("maxExpectedNumberOfInstancesInPattern: " + maxExpectedNumberOfInstancesInPattern).println();
	
	// update the pattern expected size taking into account that there are no duplicates.
	expectedNumberOfInstancesInPattern = min(expectedNumberOfInstancesInPattern, maxExpectedNumberOfInstancesInPattern);
	
	setPatternExpectedSize(pattern, computePatternSizeFromOldValue(pattern.expected_size, expectedNumberOfInstancesInPattern));
}

operation multiplySafe(a,b) {
	if (a * b < a or a * b < b) {
		if (a < 1.0 or b < 1.0) {
			// no problem
		} else {
			throw "Overflow! Parameters: a= " + a + " b= " + b;
		}
	}
	return a * b;
}

operation setPatternExpectedSize(pattern, value) {
	value = max(1.0d, value);
	pattern.expected_size = value;
}

operation fillStatisticsSingleCombinator(pattern , combinator, nodePattern2AttributeDistinctValues) {
	assert(operatorHasOneOperand(combinator), "fillStatisticsSingleCombinator with two operands in combinator " + combinator);
	
	var sourcePattern = combinator.operands.first.pattern;
	
	// we calculate the selectivity ( 1/(conditions) ) of the operation taking into account the existing conditions.
	var selectivity_denominator = computeSelectivityOperatorConditions(combinator, nodePattern2AttributeDistinctValues);
	
	("selectivity_denominator: " + selectivity_denominator).println();
	
	("sourcePattern.expected_size: " + sourcePattern.expected_size).println();
	
	var expectedNumberOfInstancesInPattern = (sourcePattern.expected_size/selectivity_denominator);
	
	("expectedNumberOfInstancesInPattern: " + expectedNumberOfInstancesInPattern).println();
	
	var maxExpectedNumberOfInstancesInPattern = 1.0d;
	
	// now calculate the statistics for each node pattern.
	// Note that cannot be more distinct patterns than the combinations of all the node distinct patterns.
	// Althouthg this creates a circular dependency between the number of distinct values for a pattern and the number of distinct values for each node pattern, it
	// is easy to see that, if the number of distinct values in the pattern restricts the number of distinct values of some node pattern, 
	// this count here will have no effect. Note that the number of instances in the pattern will never lower below the values of the number of instances for each node pattern.
	for (nodePattern in pattern.nodes) {
		("Setting size of node " + nodePattern + " ...").println;
		var nodeExpectedNumberOfInstances = fillStatisticsSingleCombinatorNodePattern(nodePattern, combinator, combinator.operands.first.pattern, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues);
		maxExpectedNumberOfInstancesInPattern = multiplySafe(maxExpectedNumberOfInstancesInPattern,nodeExpectedNumberOfInstances);
		("Size of node " + nodePattern + " Set!").println;
	}
	
	("maxExpectedNumberOfInstancesInPattern: " + maxExpectedNumberOfInstancesInPattern).println();
	
	expectedNumberOfInstancesInPattern = min(expectedNumberOfInstancesInPattern, maxExpectedNumberOfInstancesInPattern);
	
	setPatternExpectedSize(pattern, computePatternSizeFromOldValue(pattern.expected_size, expectedNumberOfInstancesInPattern));
}

operation  computePatternSizeFromOldValue(oldValue, expectedNumberOfInstancesInPattern) {
	return max(oldValue, expectedNumberOfInstancesInPattern);
}

operation fillStatisticsDoubleCombinatorNodePattern(nodePattern, combinator, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues) {
	var sourcePattern1 = combinator.operands.first.pattern;
	var sourcePattern2 = combinator.operands.last.pattern;
	
	if (isKeepNodePattern(nodePattern, sourcePattern1)) {
		// if it is a keep node from source pattern 1, we have two cases,
		// either that source node pattern belongs to a same condition of some other node pattern in source pattern 2
		// or it doesn't.
		
		("Node kept fom sourcePattern1: " + sourcePattern1).println();
		
		return fillStatisticsDoubleCombinatorNodePattern_NodeKeptFromPattern(nodePattern, sourcePattern1, sourcePattern2, combinator, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues);
		
	} else if (isKeepNodePattern(nodePattern, sourcePattern2)) {
		// if not a keep from source pattern 1, it might be a keep from source pattern 2.
		// This case is analogous to the first case: we only swap sourceNode1 with sourceNode2.
		
		("Node kept fom sourcePattern2: " + sourcePattern2).println();
		
		return fillStatisticsDoubleCombinatorNodePattern_NodeKeptFromPattern(nodePattern, sourcePattern2, sourcePattern1, combinator, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues);
		
	} else {
	
		("Node Not Kept").println();
		// in this case, we have a new node pattern instance for each pattern instance.
		// this case is handled by the fillStatisticsSingleCombinatorNodePattern function.
		return fillStatisticsSingleCombinatorNodePattern(nodePattern, combinator, sourcePattern1, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues);
	}
}

operation fillStatisticsDoubleCombinatorNodePattern_NodeKeptFromPattern(nodePattern, 
														sourcePattern1, sourcePattern2, 
														combinator, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues) {
	var sourceNodePattern1 = getCorrespondingNode(nodePattern, sourcePattern1);
	
	if (nodePatternBelongsToSameCondition(sourceNodePattern1, sourcePattern1, sourcePattern2)) {
	
		("nodePatternBelongsToSameCondition: " + nodePattern).println();
		("expectedNumberOfInstancesInPattern: " + expectedNumberOfInstancesInPattern).println();
	
		// If the source node belongs to the same condition, we have to make two calculations:
		// one as considering the sourceNode1 and the other as considering the sourceNode2.
		// Then we compute the minimum of those two because it is a natural join between sourceNode1 and sourceNode2.
		// The attributes must also be subjected to these two calculations and to the minimum between them.
		
		var sourceNodePattern2 = getOtherEndOfSameCondition(sourceNodePattern1, sourcePattern1, sourcePattern2);
		
		var expectedNumberOfDistinctValuesSourceNode1 = computeExpectedNumberOfDistinctValuesKeptNodePattern(nodePattern, combinator, sourceNodePattern1, expectedNumberOfInstancesInPattern);
		var expectedNumberOfDistinctValuesSourceNode2 = computeExpectedNumberOfDistinctValuesKeptNodePattern(nodePattern, combinator, sourceNodePattern2, expectedNumberOfInstancesInPattern);
		
		var expectedNumberOfDistinctValuesSourceNode = min(expectedNumberOfDistinctValuesSourceNode1, expectedNumberOfDistinctValuesSourceNode2);
		
		// there con not be more distinct values in a node pattern than in its owner pattern.
		expectedNumberOfDistinctValuesSourceNode = min(expectedNumberOfDistinctValuesSourceNode, expectedNumberOfInstancesInPattern);
				
		setNodePatternDistinctValues(nodePattern, computeNodePatternDistinctValuesFromOldValue(expectedNumberOfDistinctValuesSourceNode, nodePattern.expectedNumberOfDistinctValues));
		
		// cover all attributes inherited from both source node patterns
		var attributeNameSet = new Set;
		attributeNameSet.addAll(getAttributeNameList(sourceNodePattern1, nodePattern2AttributeDistinctValues).keySet());
		
		// Not necessary because the node patterns are the same, and hence, they have the same attributes.
		//attributeNameSet.addAll(getAttributeNameList(sourceNodePattern2).keySet());
		
		for (attributeName in attributeNameSet) {
			
			assert(nodePattern2AttributeDistinctValues.get(sourceNodePattern2).containsKey(attributeName));
			
			var expectedNumberOfDistinctValues1 = getAttributeDistinctValues(sourceNodePattern1, attributeName, nodePattern2AttributeDistinctValues);
			var expectedNumberOfDistinctValues2 = getAttributeDistinctValues(sourceNodePattern2, attributeName, nodePattern2AttributeDistinctValues);
			
			var expectedNumberOfDistinctValues = min(expectedNumberOfDistinctValues1, expectedNumberOfDistinctValues2);
			
			// there won be more distinct values in an attribute that in its owning node pattern
			registerAttributeDistinctValues(nodePattern, attributeName, min(expectedNumberOfDistinctValues, expectedNumberOfDistinctValuesSourceNode), nodePattern2AttributeDistinctValues);
		}
		
		// Update the displayed attribute distinct values
		updateDisplayedAttributesInNodePattern(nodePattern, nodePattern2AttributeDistinctValues);
		
		return expectedNumberOfDistinctValuesSourceNode;
		
	} else {
		// since the node pattern belongs to a single pattern, the case is treated in the same way as the 
		// fillStatisticsSingleCombinatorNodePattern function but with the source pattern 
		// as the pattern sourceNodePattern1.pattern;
		// The attributes are handled already by the function  fillStatisticsSingleCombinatorNodePattern.
		return fillStatisticsSingleCombinatorNodePattern(nodePattern, combinator, sourceNodePattern1.pattern, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues);
	}
}

operation computeNodePatternDistinctValuesFromOldValue(expectedNumberOfDistinctValuesSourceNode, oldDistinctValues) {
	/*
		We compute the max between an already existing number of distinct values because we can have 
		multiple operators resulting to the same pattern.
		In that case, we have to compute the maximum number of distinct values available.
		
		This is dificult to implemente: "After some experiments, I'd say that summing the distinct values to the old ones is a better approach.
		Since this is not just a query language, there are frequent cases were elements are created, increasing the domain of dintinct values.
		Hence, this seems to be more realistic". Maybe future work.
	*/
	return max(oldDistinctValues, expectedNumberOfDistinctValuesSourceNode);
	//return expectedNumberOfDistinctValuesSourceNode + oldDistinctValues;
}

operation computeExpectedNumberOfDistinctValuesKeptNodePattern(nodePattern, combinator, sourceNodePattern, expectedNumberOfInstancesInPattern) {
	
	var expectedNumberOfDistinctValuesNodePattern = 1.0d;
	
	/*
		if the node is kept from the source pattern to the target pattern, 
		 we have to check if there is a condition on this node pattern
		 if there is, then we assume that that condition is going to be 
		 true only for one kind of node pattern, hence the number of distinct values will be 1.

		On the other hand, if this node does not participate in the condition,
		we assume that the distribution of distinct values is independent of the distribution of the parameters of the condition,
		and so the number of instances is conservatively approximated to
		min(nDV(sourceNodePattern) , expectedNumberOfInstancesInPattern).
		Meaning that in the worst case, the number of distinct values remains the same as the source node pattern.
	*/

	if (nodeIsParameterOfSomeCondition(sourceNodePattern, combinator)) {
		
		// Even if it is a parameter, we assume that the number of distinct values does not change.
		expectedNumberOfDistinctValuesNodePattern = 1.0d;
		
	} else {
		
		assert(sourceNodePattern.expectedNumberOfDistinctValues >= 1.0d, "sourceNodePattern.expectedNumberOfDistinctValues > 1.0d in computeExpectedNumberOfDistinctValuesKeptNodePattern");
		assert(expectedNumberOfInstancesInPattern > 0.0, "expectedNumberOfInstancesInPattern > 0.0 in computeExpectedNumberOfDistinctValuesKeptNodePattern");
		
		/*
			Remember that we assumed that the conditions' (if there are any) parameters are independent of this node.
			This means that if this node has an attributes that is a parameter of some condition, the values of the
			attribute are independent of the nodes. This is not the case, for instance, for id attributes.
			Nevertheless, this remains a reasonable approximation.
			*/
		expectedNumberOfDistinctValuesNodePattern = min(sourceNodePattern.expectedNumberOfDistinctValues, expectedNumberOfInstancesInPattern);
	}
	
	assert(expectedNumberOfDistinctValuesNodePattern > 0.0d, "expectedNumberOfDistinctValuesNodePattern > 0.0d in computeExpectedNumberOfDistinctValuesKeptNodePattern");
	
	return expectedNumberOfDistinctValuesNodePattern;
}

operation fillStatisticsSingleCombinatorNodePattern(nodePattern, combinator, sourcePattern, expectedNumberOfInstancesInPattern, nodePattern2AttributeDistinctValues) {
	
	var expectedNumberOfDistinctValuesNodePattern = 0.0d;
	
	if (isKeepNodePattern(nodePattern, sourcePattern)) {
		
		var sourceNodePattern = getCorrespondingNode(nodePattern, sourcePattern);
		
		expectedNumberOfDistinctValuesNodePattern = computeExpectedNumberOfDistinctValuesKeptNodePattern(nodePattern, combinator, sourceNodePattern, expectedNumberOfInstancesInPattern);

		
		// We can never have more distinct values in a node pattern then instances in the pattern...
		expectedNumberOfDistinctValuesNodePattern = min(expectedNumberOfDistinctValuesNodePattern, expectedNumberOfInstancesInPattern);
		
		
		setNodePatternDistinctValues(nodePattern, computeNodePatternDistinctValuesFromOldValue(expectedNumberOfDistinctValuesNodePattern, nodePattern.expectedNumberOfDistinctValues));
		
		
		// fill the statistics for the attributes.
		/*
		Since this is a kept node, by default it ihnerits all the statistics for the attributes of the sourceNodePattern.
		However, each statistic is conditioned to the number of distinct instances of the new node pattern.
		And we have to update the statiscts for the attributes that are involved in some condition of the operator.
		*/
		
		// inherit all attributes (restricted to the number of distinct instances of the new node pattern)
		for (attributeName in getAttributeNameList(sourceNodePattern, nodePattern2AttributeDistinctValues).keySet()) {
			var expectedNumberOfDistinctValues = getAttributeDistinctValues(sourceNodePattern, attributeName, nodePattern2AttributeDistinctValues);
			// there won be more distinct values in an attribute that in its owning node pattern
			registerAttributeDistinctValues(nodePattern, attributeName, min(expectedNumberOfDistinctValues, expectedNumberOfDistinctValuesNodePattern), nodePattern2AttributeDistinctValues);
		}
		
		// update the statistics for attribute involved in the condition.
		for (sourceAttributePattern in sourceNodePattern.attributes) {
			if (attributeIsParameterOfSomeCondition(sourceAttributePattern, combinator)) {
				/*
				In this case we assume the condition is verifying if the attribute has some given value.
				Which means the number of distinct values for this attribute in the end is one.
				*/
				registerAttributeDistinctValues(nodePattern, sourceAttributePattern.name, 1.0d, nodePattern2AttributeDistinctValues);
			}
		}
		
		assert(expectedNumberOfDistinctValuesNodePattern > 0.0, "expectedNumberOfDistinctValuesNodePattern > 0.0 in fillStatisticsSingleCombinatorNodePattern [then]");
		
	} else {
		// then a new instance is created for each new pattern instance.
		expectedNumberOfDistinctValuesNodePattern = expectedNumberOfInstancesInPattern;
		
		setNodePatternDistinctValues(nodePattern, computeNodePatternDistinctValuesFromOldValue(expectedNumberOfDistinctValuesNodePattern, nodePattern.expectedNumberOfDistinctValues));
		
		// fill the statistics for the attributes.
		/*
		The new instance only has the attributes that are the result of some function.
		We assume that that function is injective.
		This means that the number of distinct values of the target attribute is the minimum
		between the number of distinct node instances, and the number of distinct values for the source attribute (the first parameter) of that function.
		
		An attribute that is declared but which does not receive any value yields an error.
		*/
		for (attributePattern in nodePattern.attributes) {
			var calculationForAttributePattern = getAttributeCalculationCallsTargetingAttribute(attributePattern, combinator).first;
			
			//assert(calculationForAttributePattern<>null , "Attribute declared but not result of any calculation found: " + attributePattern.name + " in node " + nodePattern.id + " in pat " + nodePattern.pattern.id + " -> Maybe there a node pattern as parameter.");
			var expectedNumberOfDistinctValues;
			
			if (calculationForAttributePattern == null) {
				// Is a constant calculation, which means the number of distinct values is 1.
				expectedNumberOfDistinctValues = 1.0d;
				
			} else {
				var sourceAttributePattern = getFirstParameterInCalculation(calculationForAttributePattern);
				
				if (sourceAttributePattern == null) {
					expectedNumberOfDistinctValues = 1.0d;
				} else {
					expectedNumberOfDistinctValues = sourceAttributePattern.expectedNumberOfDistinctValues;				
				}
				
			}
			
			registerAttributeDistinctValues(nodePattern, attributePattern.name, min(expectedNumberOfDistinctValues, expectedNumberOfDistinctValuesNodePattern), nodePattern2AttributeDistinctValues);
		}
		
		assert(expectedNumberOfDistinctValuesNodePattern > 0.0, "expectedNumberOfDistinctValuesNodePattern > 0.0 in fillStatisticsSingleCombinatorNodePattern [else]");
	}
	
	
	// finally, update the value for any attribute pattern existing in the target node pattern.
	updateDisplayedAttributesInNodePattern(nodePattern, nodePattern2AttributeDistinctValues);
	
	assert(expectedNumberOfDistinctValuesNodePattern > 0.0, "expectedNumberOfDistinctValuesNodePattern > 0.0 in fillStatisticsSingleCombinatorNodePattern");
	
	return expectedNumberOfDistinctValuesNodePattern;
	
}


operation getFirstParameterInCalculation(calculationForAttributePattern) {
	("getFirstParameterInCalculation : getFirstParameterInCalculation: " + calculationForAttributePattern).println();
	
	var potencialParameters = getAllParameters(calculationForAttributePattern);
	
	return potencialParameters.first;

}

operation getAllParameters(calculationForAttributePattern) {
	var result = new Bag;
	
	for (parameterRef in calculationForAttributePattern.parameters) {
		var parameter = parameterRef.parameter;
		if (parameter.isKindOf(VisualModel!AttributePattern)) {
			result.add(parameter);		
		} else if (parameter.isKindOf(VisualModel!NodePattern)) {
			result.add(parameter);
		} else if (parameter.isKindOf(VisualModel!ExternalCalculationCall)) {
			result.addAll(getAllParameters(parameter));
		} else {
			assert (false, "Unexpected kind of parameter found in getAllParameters");
		}
	}
	
	return result;
	
}

operation updateDisplayedAttributesInNodePattern(nodePattern, nodePattern2AttributeDistinctValues){
	for (attributePattern in nodePattern.attributes) {
		var expectedNumberOfDistinctValues = getAttributeDistinctValues(nodePattern, attributePattern.name, nodePattern2AttributeDistinctValues);
		attributePattern.expectedNumberOfDistinctValues = expectedNumberOfDistinctValues;
	}
}

operation nodePatternBelongsToSameCondition(nodePattern, pattern1, pattern2) {
	assert(pattern1.nodes.includes(nodePattern), "Wrong usage of function nodePatternBelongsToSameCondition");
	
	return nodePattern.sameOut.exists( cond | conditionIsBetweenPatterns(cond, pattern1, pattern2))
		or nodePattern.sameIn.exists( cond | conditionIsBetweenPatterns(cond, pattern1, pattern2));
}

operation getOtherEndOfSameCondition(nodePattern, pattern1, pattern2) {
	assert(pattern1.nodes.includes(nodePattern), "Wrong usage of function getOtherEndOfSameCondition");
	
	for (condition in nodePattern.sameOut) {
		if (conditionIsBetweenPatterns(condition, pattern1, pattern2)) {
			return condition.target;
		}
	}
	
	for (condition in nodePattern.sameIn) {
		if (conditionIsBetweenPatterns(condition, pattern1, pattern2)) {
			return condition.source;
		}
	}
	
	assert(false, "Condition not found in function getOtherEndOfSameCondition");
	
}

operation conditionIsBetweenPatterns(cond, pattern1, pattern2) {
	return ( pattern1.nodes.includes(cond.source) and pattern2.nodes.includes(cond.target) ) or 
			( pattern1.nodes.includes(cond.target) and pattern2.nodes.includes(cond.source) );
}

operation getAttributeCalculationCallsTargetingAttribute(attributePattern, operator) {
	// TODO: cover also the case were the parameters are node patterns.
	
	assert(attributePattern.attributeExternalCalculationCall <> null, "Wrong usage of function getFirstAttributeCalculationCallsTargetingAttribute");
	
	if (operator.operands.size() == 1) {
		var sourcePattern = operator.operands.first.pattern;	
		return attributePattern.attributeExternalCalculationCall.select(attrCalculation | calculationHasAtLeastOneParameterInsidePattern(attrCalculation, sourcePattern));
	} else {
		assert(operator.operands.size() == 2, "Invalid number of operands for operator " + operator);
		
		var result = new Bag;
		
		var sourcePattern1 = operator.operands.first.pattern;
		var sourcePattern2 = operator.operands.last.pattern;
		
		result.addAll(attributePattern.attributeExternalCalculationCall.select(attrCalculation |  calculationHasAtLeastOneParameterInsidePattern(attrCalculation, sourcePattern1)));
		result.addAll(attributePattern.attributeExternalCalculationCall.select(attrCalculation | calculationHasAtLeastOneParameterInsidePattern(attrCalculation, sourcePattern2)));
		
		return result;
	}
}

operation calculationHasAtLeastOneParameterInsidePattern(attrCalculation, sourcePattern) {
	return attrCalculation.parameters.collect(param | param.parameter).exists(attrPattern | attrPattern.isKindOf(VisualModel!AttributePattern) and attributePatternIsContainedInPattern(attrPattern, sourcePattern));
}

operation attributePatternIsContainedInPattern(attrPattern, sourcePattern) {
	return sourcePattern.nodes.collect(node | node.attributes).exists(setOfAttrs | setOfAttrs.includes(attrPattern));
}

operation nodeIsParameterOfSomeCondition(sourceNodePattern, combinator) {
	return combinator.conditions.exists(condition | condition.isKindOf(VisualModel!ExternalConditionCall) and condition.parameters.exists(paramRef | paramRef.parameter == sourceNodePattern));
}

operation attributeIsParameterOfSomeCondition(sourceAttributePattern, combinator) {
	return combinator.conditions.exists(condition | condition.isKindOf(VisualModel!ExternalConditionCall) and condition.parameters.exists(paramRef | paramRef.parameter == sourceAttributePattern));
}

operation getCorrespondingNode(node, pattern) {
	return node.keepIn.selectOne(rel : CoreModel!Keep | patternContains(pattern, rel.source)).source;
}

operation patternContains(pattern, node) {
	return pattern.nodes.includes(node);
}

operation isKeepNodePattern(node, sourcePattern){
	return hasAKeepRelationInSourcePattern(node, sourcePattern);
}

operation hasAKeepRelationInSourcePattern(node, sourcePattern){
	return sourcePattern.nodes.exists(sourceNode: CoreModel!NodePattern | hasAKeepRelation(sourceNode, node));
}

operation hasAKeepRelation(sourceNode, targetNode){
	return sourceNode.keepOut.exists(relation:CoreModel!Keep | relation.target = targetNode);
}


operation assert(condition, message) {
	if (not condition) {
		throw "Assertion error: " + message;
	}
}

operation computeSelectivityOperatorJoinConditions(combinator, sourcePattern1, sourcePattern2) {
	
	var sameConditionsBetweenPatterns = getSameConditionsBetweenPatterns(sourcePattern1, sourcePattern2);
	
	var result = 1.0d;
	
	for (sameCondition in sameConditionsBetweenPatterns) {
		var targetNodePattern = getNodePatternFromPatternInCondition(sameCondition, sourcePattern2);
		("sourcePattern2.expected_size: " + sourcePattern2.expected_size).println();
		("getNumberOfDistinctValuesNodePattern(targetNodePattern): " + getNumberOfDistinctValuesNodePattern(targetNodePattern)).println();
		if (getNumberOfDistinctValuesNodePattern(targetNodePattern) >= 1.0) {
			assert (sourcePattern2.expected_size >= getNumberOfDistinctValuesNodePattern(targetNodePattern), "Invariant sourcePattern2.expected_size >= getNumberOfDistinctValuesNodePattern(targetNodePattern) violated! sourcePattern2: " + sourcePattern2 + "; targetNodePattern: " + targetNodePattern + "; sourcePattern1: " + sourcePattern1 );
		}
		
		result = result * getNumberOfDistinctValuesNodePattern(targetNodePattern);
	}
	
	assert(result > 0.0d, "Invalid selectivity result in computeSelectivityOperatorJoinConditions."); 
	
	return result;
}

operation getNodePatternFromPatternInCondition(sameCondition, pattern) {
	
	if (pattern.nodes.includes(sameCondition.source)) {
		return sameCondition.source;
	}
	
	if (pattern.nodes.includes(sameCondition.target)) {
		return sameCondition.target;
	}
	
	assert(false, "This should not happen in getNodePatternFromPatternInCondition");
	
}

operation getSameConditionsBetweenPatterns(sourcePattern1, sourcePattern2) {
	var result = new Bag;
	for (nodePattern1 in sourcePattern1.nodes) {
		// the direction of the same condition does not matter
		for (sameCondition in nodePattern1.sameOut) {
			var nodePattern2 = sameCondition.target;
			assert (nodePattern2 <> nodePattern1, "Same condition to the same element found in getSameConditionsBetweenPatterns");
			if (sourcePattern2.nodes.includes(nodePattern2)) {
				result.add(sameCondition);
			}
		}
		for (sameCondition in nodePattern1.sameIn) {
			var nodePattern2 = sameCondition.source;
			assert (nodePattern2 <> nodePattern1, "Same condition to the same element found in getSameConditionsBetweenPatterns");
			if (sourcePattern2.nodes.includes(nodePattern2)) {
				result.add(sameCondition);
			}
		}
	}
	
	return result;
}

operation computeSelectivityOperatorConditions(operator, nodePattern2AttributeDistinctValues) {
	// computes the selectivity denominator for each possible result.
	// As a simplification, we treat each aditional condition as a conjuntion.
	// this might not be true for all conditions but as an approximation rule of thumb it is fine.
	// Also, for each condition, we only take into account the first parameter. 
	// Again, in general this remains a good approximation.
	// Also, conditions without parameters are assumed to be always true.
	// var sourcePattern = operator.operands.first.pattern;
	
	
	var result = 1.0d;
	for (appCondition in operator.conditions) {
		 assert(appCondition.isKindOf(VisualModel!ExternalConditionCall), "Unexpected kind of ApplicationCondition: " + appCondition);
		 
		 for (parameterRef in appCondition.parameters) {
		 	if (parameterRef.index == 0) {
		 		
		 		var parameter = parameterRef.parameter;
		 		
		 		if (parameter.isKindOf(VisualModel!Calculation)) {
		 			//TODO recursively fetch the node or the attribute pattern;
		 			// assign parameter to that.
		 			// don't forget to update attributeIsParameterOfSomeCondition and nodeIsParameterOfSomeCondition functions too! They have to search recursevly to see if a certain element is a parameter.
		 			throw "Not implemented yet!";
		 		}
		 		
		 		if (parameter.isKindOf(VisualModel!AttributePattern)) {
		 			// I think the minimum here is redundant since sourcePattern.expected_size will always be greater or equal to the number of distinct values by construction.
		 			// We can make this an invariant.
		 			// Unless there attributes that are lists. In that case, a single node pattern can have a helluva lot attributes. But we are not covering that case. 
		 			assert (parameter.ownerNode.pattern.expected_size >= getNumberOfDistinctValuesAttributePattern(parameter, nodePattern2AttributeDistinctValues), "Invariant sourcePattern.expected_size >= getNumberOfDistinctValuesAttributePattern(parameter) violated!");
		 			result = result * getNumberOfDistinctValuesAttributePattern(parameter, nodePattern2AttributeDistinctValues);
		 		} else if (parameter.isKindOf(VisualModel!NodePattern)) {
		 			// assert (sourcePattern.expected_size >= getNumberOfDistinctValuesNodePattern(parameter), "Invariant sourcePattern.expected_size >= getNumberOfDistinctValuesNodePattern(parameter) violated!");
		 			
		 			// we ignore these parameters.
		 			//result = result * (getNumberOfDistinctValuesNodePattern(parameter));
		 		}
		 	}
		 	
		 }
	}
	
	assert(result > 0.0d, "Invalid selectivity result.");
	
	return result;
}

operation getNumberOfDistinctValuesAttributePattern(attributePattern, nodePattern2AttributeDistinctValues) {
	var attributeDistinctValues = getAttributeDistinctValues(attributePattern.ownerNode, attributePattern.name, nodePattern2AttributeDistinctValues);
	assert (attributeDistinctValues <> null, "Missing distinct values for attribute " + attributePattern);
	assert (attributeDistinctValues > 0.0d, "Invalid number of distinct values");
	return attributeDistinctValues;
}

operation getNumberOfDistinctValuesNodePattern(nodePattern) {
	var distinctValues = nodePattern.expectedNumberOfDistinctValues;
	assert (distinctValues >= 1.0d, "Invalid number of distinct values");
	return distinctValues;
}

operation setNodePatternDistinctValues(nodePattern, value) {
	assert(value > 0.0d, "Invalid number of distinct values in Invalid number of distinct values");
	value = max(1.0d, value);
	
	nodePattern.expectedNumberOfDistinctValues = value;
}


operation getAllSuitedPatterns() {
	return VisualModel!Pattern.all().select(p| isUnfilled(p) and canBeFilled(p));
}

operation canBeFilled(pattern) {
	return hasFilledParents(pattern);
}

operation hasFilledParents(pattern) {
	return getAllParentsSet(pattern).forAll(p | isFilled(p));
}

operation isUnfilled(pattern) {
	return (pattern.expected_size.isUndefined) or (pattern.expected_size==0); // TODO when the network is disconected (and hence, invalid) this goes in an infinite cycle.
}

operation getAllParentsSet(pattern) {
	var result = new Set;
	
	for (operator in getIncomingOperatorsSet(pattern)) {
		result.addAll(getIncomingPatternsSet(operator));
	}
	
	return result;
}

operation getIncomingPatternsSet(operator){
	return operator.operands.collect(operand | operand.pattern).asSet();
}

operation getIncomingOperatorsSet(pattern) {
	return pattern.incomingResults.collect(result | result.operator).asSet();
}

operation clearAllExpectedSizes(){
	"Clearing sizes for all patterns...".println();
	for (pattern in VisualModel!Pattern.all) {
		pattern.expected_size = 0.0d;
		
	}
	
	for (node in VisualModel!NodePattern.all) {
		node.expectedNumberOfDistinctValues = 0.0d;
	}
	
	for (attribute in VisualModel!AttributePattern.all) {
		attribute.expectedNumberOfDistinctValues = 0.0d;
	}
	
	"Clearing sizes for all patterns... DONE".println();
}

operation getAllNonStartingPatterns(){
	return VisualModel!Pattern.all().select(e | not isAStartPattern(e));
}

operation estimateExpectedSizesInStartPatterns(nodePattern2AttributeDistinctValues){
	"Estimating size for start patterns...".println();
	
	for (startPattern in getAllStartPatterns()){
		fillPatternEstimateFromCatalog(startPattern, nodePattern2AttributeDistinctValues);
		("Size estimated for pattern " + startPattern).println();
	}
	
	"Estimating size for start patterns... DONE".println();
	
}

operation allStartPatternsHaveDefinedExpectedSizes() {
	return getAllStartPatterns().forAll(p | isFilled(p));
}

operation min(a,b) {
	if (a>b) {
		return b;
	} else {
		return a;
	}
}

operation max(a,b) {
	if (a>b) {
		return a;
	} else {
		return b;
	}
}

operation isFilled(pattern) {
	return not isUnfilled(pattern);
}

operation getAllStartPatterns(){
	return VisualModel!Pattern.all().select(e | isAStartPattern(e));
}

operation isAStartPattern(pattern) {
	return not pattern.incomingResults.select(r | resultsComesFromAnExternalOperator(r)).isEmpty();
}

operation resultsComesFromAnExternalOperator(result) {
	return result.operator.isKindOf(VisualModel!External);
}

operation operatorHasTwoOperands(operator){
	return operator.operands.size() == 2;
}
operation operatorHasOneOperand(operator){
	return operator.operands.size() == 1;
}

operation fillPatternEstimateFromCatalog(pattern, nodePattern2AttributeDistinctValues) {
	if (isAtomicNodePattern(pattern)) {
		var nodeTypeCatalog = getNodeFromCatalog(pattern.nodes.first);
		var nodeNumberOfDistinctValues = nodeTypeCatalog.aggregatedNumberOfInstances + 0.0d;
		setPatternExpectedSize(pattern, max(nodeNumberOfDistinctValues, 1.0d));
		setNodePatternDistinctValues(pattern.nodes.first, max(nodeNumberOfDistinctValues, 1.0d));
		
		var nodePattern = pattern.nodes.first;
		
		("pattern: " + pattern).println();
		("nodePattern: " + nodePattern).println();
		
		// fill attribute statistics for this node.
		for (attributeCatalog in nodeTypeCatalog.attributes) {
			registerAttributeDistinctValues(nodePattern, attributeCatalog.name, attributeCatalog.aggregatedNumberOfDistinctValues, nodePattern2AttributeDistinctValues);
		}
		
		// register the distinct values for each attribute pattern. Event if there aren't any, we still keep the attribute catalogs because they might be needed later.
		for (attributePattern in nodePattern.attributes) {
			var attributeCatalogDistinctValues = getAttributeDistinctValues(nodePattern, attributePattern.name, nodePattern2AttributeDistinctValues);
			assert(attributeCatalogDistinctValues <> null, "Missing catalog information for attribute " + attributePattern);
			attributePattern.expectedNumberOfDistinctValues = attributeCatalogDistinctValues;
		}
		
		
		
	} else {
		if( not isAtomicEdgePattern(pattern)) {
			throw "Non atomic pattern found! " ;
		}
		
		var edge = pattern.edges.first;
		var sourceNode = edge.source;
		var targetNode = edge.target;
		
		var edgeCatalog = getEdgeFromCatalog(edge);
		
		setPatternExpectedSize(pattern, max(edgeCatalog.aggregatedNumberOfInstances + 0.0d, 1.0d));
		
		setNodePatternDistinctValues(sourceNode, max(edgeCatalog.aggregatedNumberOfDistinctSourceInstances + 0.0d, 1.0d));
		setNodePatternDistinctValues(targetNode, max(edgeCatalog.aggregatedNumberOfDistinctTargetInstances + 0.0d, 1.0d));
		
		var sourceNodeTypeCatalog = getNodeFromCatalog(sourceNode);
		var targetNodeTypeCatalog = getNodeFromCatalog(targetNode);
		
		// fill attribute statistics for source node. Remember that there are no more attribute distinct values in a node's attribute than in the node itself.
		for (attributeCatalog in sourceNodeTypeCatalog.attributes) {
			registerAttributeDistinctValues(sourceNode, attributeCatalog.name, min(sourceNode.expectedNumberOfDistinctValues, attributeCatalog.aggregatedNumberOfDistinctValues), nodePattern2AttributeDistinctValues);
		}
		// fill attribute statistics for target node. Remember that there are no more attribute distinct values in a node's attribute than in the node itself.
		for (attributeCatalog in targetNodeTypeCatalog.attributes) {
			registerAttributeDistinctValues(targetNode, attributeCatalog.name, min(targetNode.expectedNumberOfDistinctValues,attributeCatalog.aggregatedNumberOfDistinctValues), nodePattern2AttributeDistinctValues);
		}
		
		
		for (attributePattern in sourceNode.attributes) {
			var attributeCatalogDistinctValues = getAttributeDistinctValues(sourceNode, attributePattern.name, nodePattern2AttributeDistinctValues);
			assert(attributeCatalogDistinctValues <> null, "Missing catalog information for attribute " + attributePattern);
			attributePattern.expectedNumberOfDistinctValues = attributeCatalogDistinctValues;
		}
		for (attributePattern in targetNode.attributes) {
			var attributeCatalogDistinctValues = getAttributeDistinctValues(targetNode, attributePattern.name, nodePattern2AttributeDistinctValues);
			assert(attributeCatalogDistinctValues <> null, "Missing catalog information for attribute " + attributePattern);
			attributePattern.expectedNumberOfDistinctValues = attributeCatalogDistinctValues;
		}
		
	}
}

operation registerAttributeDistinctValues(nodePattern, attributeName, numberOfDistinctValues, nodePattern2AttributeDistinctValues) {
	
	var oldAttributeNumberOfDistinctValues = 1.0d;
	
	if (nodePattern2AttributeDistinctValues.get(nodePattern).containsKey(attributeName)) {
		oldAttributeNumberOfDistinctValues = nodePattern2AttributeDistinctValues.get(nodePattern).get(attributeName);
	}
	
	// we compute the max between the old number of distincts and the new because we can have multiple operators 
	// pointing to the same result pattern.
	nodePattern2AttributeDistinctValues.get(nodePattern).put(attributeName, max(numberOfDistinctValues+0.0d , oldAttributeNumberOfDistinctValues));
}

operation initializeNodePattern2AttributeDistinctValues(nodePattern2AttributeDistinctValues) {
	for (nodePattern in VisualModel!NodePattern.all) {
		nodePattern2AttributeDistinctValues.put(nodePattern, new Map);
	}
}

operation getAttributeDistinctValues(nodePattern, attributeCatalogName, nodePattern2AttributeDistinctValues) {
	return nodePattern2AttributeDistinctValues.get(nodePattern).get(attributeCatalogName);
}

operation getAttributeNameList(nodePattern, nodePattern2AttributeDistinctValues) {
	assert(nodePattern2AttributeDistinctValues.containsKey(nodePattern), "nodePattern2AttributeDistinctValues does not contain key " + nodePattern);
	
	return nodePattern2AttributeDistinctValues.get(nodePattern);
}

operation getNodeFromCatalog(node) {
	var nodeTypeCatalog = CatalogModel!TypeCatalog.all.selectOne(c | c.name = node.name);
	if (nodeTypeCatalog = null) {
		CatalogModel!TypeCatalog.all.println();
		throw "No type catalog found for node " + node;
	}
	return nodeTypeCatalog;
}

operation getEdgeFromCatalog(edge) {
	var resultSet = CatalogModel!ReferenceCatalog.all.select(e | e.name = edge.name);
	
	// search for the specific edge (accounting for source and target nodes)
	var result = resultSet.selectOne(e | e.source.name = edge.source.name and e.target.name = edge.target.name);
	
	if (result = null) {
		CatalogModel!ReferenceCatalog.all.println();
		throw "No reference catalog found for edge " + edge;
	}
	
	return result;
}

// tests
operation isAtomicNodePattern(pattern) {
	return (pattern.nodes.size==1);
}

operation isAtomicEdgePattern(pattern) {
	return (pattern.nodes.size==2 and pattern.edges.size==1);
}



operation getTransformationRootPackage() {
	var trnetModel = CoreModel!TrNetModel.all.first;
	return trnetModel.id.toLowerCase();
}

operation getPackageTransformation() {
	return getTransformationRootPackage();
}

operation getPackageGenericPatternListener() {
	return getGenericPackage();
}

operation getGenericPackage(){
	return "generic";
}

operation getPackagePattern(pattern) {
	return getTransformationRootPackage();
}

operation getPackageNodePattern(node){
	return getTransformationRootPackage();
}

operation getPackageGenericNode() {
	return getGenericPackage();
}

operation getPackageGenericPattern() {
	return getGenericPackage();
}

operation getPackageGenericPatternPublisher() {
	return getGenericPackage();
}

operation getPackageGenericEdge() {
	return getGenericPackage();
}

operation getTransformationClass() {
	var trnetModel = CoreModel!TrNetModel.all.first;
	return trnetModel.id.firstToUpperCase() + "Transformation";
}

operation getTransformationClassFile() {
	return getTransformationClass() + ".java";
}

operation getJavaClassName(pattern) {
	return getClassPattern(pattern) + ".java";
}

operation getGenericPatternInterfaceListenerFile() {
	return getGenericPatternInterfaceListener() + ".java";
}

operation getGenericPatternInterfacePublisherFile() {
	return getGenericPatternInterfacePublisher() + ".java";
}

operation getGenericPatternInterfaceListener() {
	return "ModelPatternListener";
}

operation getGenericPatternInterfacePublisher() {
	return "ModelPatternPublisher";
}

operation getGenericNodeClassFile(){
	return getGenericNodeClass() + ".java";
}

operation getGenericPatternClassFile() {
	return getGenericPatternClass() + ".java";
}

operation getGenericPatternClass() {
	return "ModelPattern";
}

operation getGenericNodeClass() {
	return "ModelNode";
}

operation getGenericEdgeClassFile(){
	return getGenericEdgeClass() + ".java";
}

operation getGenericEdgeClass() {
	return "ModelEdge";
}

operation getClassPattern(pattern) {
	return pattern.id.firstToUpperCase() + "Instance";
}

operation getJavaInterfaceNamePatternListener(pattern){
	return getInterfacePatternListener(pattern) + ".java";
}

operation getJavaInterfaceNamePatternPublisher(pattern){
	return getInterfacePatternPublisher(pattern) + ".java";
}

operation getInterfacePatternListener(pattern){
	return pattern.id.firstToUpperCase() + "InstanceListener";
}

operation getInterfacePatternPublisher(pattern){
	return pattern.id.firstToUpperCase() + "InstancePublisher";
}

operation getJavaClassFileExternalInputOperator(externalInputOperator){
	return getJavaClassExternalInputOperator(externalInputOperator) + ".java";
}

operation getJavaClassNameNode(node){
	return getClassNodePattern(node) + ".java";
}

operation getClassNodePattern(node){
	//return node.name.firstToUpperCase() + "NodeInstance";
	return "ModelNode";
}

operation getJavaClassExternalInputOperator(externalInputOperator) {
	return externalInputOperator.id.firstToUpperCase() + "ExternalInput";
}

operation getJavaClassFileExternalOutputOperator(externalOutputOperator){
	return getJavaClassExternalOutputOperator(externalOutputOperator) + ".java";
}

operation getJavaClassExternalOutputOperator(externalOutputOperator) {
	return externalOutputOperator.id.firstToUpperCase() + "ExternalOutput";
}

operation getPackageExternalInputOperator(externalInputOperator){
	return getTransformationRootPackage();
}

operation getPackagePatternListener(pattern){
	return getTransformationRootPackage();
}

operation getPackagePatternPublisher(pattern){
	return getTransformationRootPackage();
}

operation getPackageExternalOutputOperator(externalOutputOperator){
	return getTransformationRootPackage();
}

operation getPatternSucessorsFromOperator(operator){
	return operator.results.collect(element | element.pattern );
}

operation getOperatorSucessorsFromPattern(pattern) {
	return pattern.outgoingOperands.collect(element | element.operator);
}

operation getPatternPredecessorsFromOperator(operator){
	return operator.operands.collect(element | element.pattern );
}

operation getOperatorPredecessorsFromPattern(pattern){
	return pattern.incomingResults.collect(result | result.operator );
}

operation getFieldNameNodePattern(node){
	return node.id.firstToLowerCase();
}

operation getAllExternalInputOperators() {
	return CoreModel!External.all.select(external: CoreModel!External | isInputOperator(external));
}

operation getAllInternalOperators() {
	return CoreModel!Operator.all.reject(op: CoreModel!Operator | isExternalOperator(op) );
}

operation getAllInternalOrOutputOperators() {
	return CoreModel!Operator.all.select(op: CoreModel!Operator | isInternalOperator(op) or isOutputOperator(op) );
}

operation isExternalOperator(op){
	return op.isKindOf(CoreModel!External);
}

operation isInternalOperator(op){
	return not isExternalOperator(op);
}

operation isDecomposableOperator(op){
	return isInternalOperator(op) and op.operands.size()>2;
}

operation isInputOperator(external) {
	return external.operands.isEmpty();
}

operation isOutputOperator(external) {
	return external.results.isEmpty();
}

operation getAllExternalOutputOperators() {
	return CoreModel!External.all.select(external: External| isOutputOperator(external));
}

operation isOutputOperator(external) {
	return external.results.isEmpty();
}

operation getRestrictions(operator) {
	var result = new Bag;
	result.addAll(findOperatorSameRestrictions(operator));
	result.addAll(findOperatorDifferentRestrictions(operator));
	result.addAll(findOperatorKeepRestrictions(operator));
	return result;
}

operation min(a,b) {
	if (a>b) {
		return b;
	} else {
		return a;
	}
}

operation max(a,b) {
	if (a>b) {
		return a;
	} else {
		return b;
	}
}

operation findOperatorKeepRestrictions(operator) {
	return CoreModel!Keep.all.select(keepRestriction | hasSourceInSomePatternKeepRestriction(keepRestriction, getIncomingPatternsSet(operator)) and hasTargetInSomePatternKeepRestriction(keepRestriction, getOutgoingPatternsSet(operator)));
}

operation findOperatorSameRestrictions(operator) {
  return CoreModel!Same.all.select(sameRestriction | hasSourceInSomePatternSameRestriction(sameRestriction, getIncomingPatternsSet(operator)) and hasTargetInSomePatternSameRestriction(sameRestriction, getIncomingPatternsSet(operator)));
}

operation findOperatorDifferentRestrictions(operator) {
  return VisualModel!Different.all.select(differentRestriction | hasSourceInSomePatternDifferentRestriction(differentRestriction, getIncomingPatternsSet(operator)) and hasTargetInSomePatternDifferentRestriction(differentRestriction, getIncomingPatternsSet(operator)));
}

operation getIncomingPatternsSet(operator){
	return operator.operands.collect(operand | operand.pattern).asSet();
}

operation getOutgoingPatternsSet(operator){
	return operator.results.collect(result | result.pattern).asSet();
}

operation hasSourceInSomePatternSameRestriction(sameRestriction, setOfPatterns){
	return setOfPatterns.exists(somePattern | hasSourceInPatternSameRestriction(sameRestriction, somePattern));
}

operation hasSourceInSomePatternDifferentRestriction(differentRestriction, setOfPatterns){
	return setOfPatterns.exists(somePattern | hasSourceInPatternDifferentRestriction(differentRestriction, somePattern));
}

operation hasSourceInSomePatternKeepRestriction(keepRestriction, setOfPatterns){
	return setOfPatterns.exists(somePattern | hasSourceInPatternKeepRestriction(keepRestriction, somePattern));
}

operation hasSourceInPatternKeepRestriction(keepRestriction, somePattern){
	return somePattern.nodes.exists(someNode | keepRestriction.source = someNode);
}

operation hasTargetInSomePatternSameRestriction(sameRestriction, setOfPatterns){
	return setOfPatterns.exists(somePattern | hasTargetInPatternSameRestriction(sameRestriction, somePattern));
}

operation hasTargetInSomePatternDifferentRestriction(differentRestriction, setOfPatterns){
	return setOfPatterns.exists(somePattern | hasTargetInPatternSameRestriction(differentRestriction, somePattern));
}

operation hasTargetInSomePatternKeepRestriction(keepRestriction, setOfPatterns){
	return setOfPatterns.exists(somePattern | hasTargetInPatternKeepRestriction(keepRestriction, somePattern));
}

operation hasSourceInPatternSameRestriction(sameRestriction, somePattern){
	return somePattern.nodes.exists(someNode | sameRestriction.source = someNode);
}

operation hasSourceInPatternDifferentRestriction(differentRestriction, somePattern){
	return somePattern.nodes.exists(someNode | differentRestriction.source = someNode);
}

operation hasTargetInPatternSameRestriction(differentRestriction, somePattern){
	return somePattern.nodes.exists(someNode | differentRestriction.target = someNode);
}

operation hasTargetInPatternSameRestriction(sameRestriction, somePattern){
	return somePattern.nodes.exists(someNode | sameRestriction.target = someNode);
}

operation hasTargetInPatternKeepRestriction(keepRestriction, somePattern){
	return somePattern.nodes.exists(someNode | keepRestriction.target = someNode);
}

operation getAllInputPatterns(){
	return CoreModel!Pattern.all.select(pattern | isInputPattern(pattern));
}

operation getAllOutputPatterns() {
	return CoreModel!Pattern.all.select(pattern | isOutputPattern(pattern));
}

operation isInputPattern(pattern){
	return isConnectedToSomeInputOperator(pattern);
}

operation isOutputPattern(pattern){
	return isConnectedToSomeOutputOperator(pattern);
}

operation isConnectedToSomeInputOperator(pattern){
	return pattern.incomingResults.collect(incRes | incRes.operator).exists(op | isInputOperator(op));
}

operation isConnectedToSomeOutputOperator(pattern){
	return pattern.outgoingOperands.collect(outOp | outOp.operator).exists(op | isOutputOperator(op));
}


operation getConditionsWithFirstParameterInPattern(conditions, pattern) {
	return conditions.select(cond | pattern.nodes.collect(n | n.attributes).exists(attrsSet | attrsSet.includes(getFirstParameterCondition(cond))));
}

operation getFirstParameterCondition(cond) {
	return cond.parameters.selectOne(param| param.index == 0).parameter;
}

operation getSourcePattern(joinCondition) {
	return joinCondition.source.pattern;
}

operation getTargetPattern(joinCondition) {
	return joinCondition.target.pattern;
}


operation selectMostRestrictiveJoinCondition(operator) {
	var maxSelectivityDenominator = 0.0d;
	var mostRestrictiveSameCondition = null;
	
	for (sameCondition in findOperatorSameRestrictions(operator)) {
		var selDenAux = computeConditionSelectivityDenominator(sameCondition);
		if (selDenAux > maxSelectivityDenominator) {
			maxSelectivityDenominator = selDenAux;
			mostRestrictiveSameCondition = sameCondition;
		}
	}
	
	assert(mostRestrictiveSameCondition==null implies findOperatorSameRestrictions(operator).isEmpty(), "Error in selectMostRestrictiveJoinCondition.");
	
	return mostRestrictiveSameCondition;
}

operation dependsOnlyOnOnePattern(condition, pattern) {
	return collectAllConditionParameters(condition.parameters).forAll(param | parameterBelongsToPattern(param, pattern));
}

operation parameterBelongsToPattern(parameter, pattern) {
	
	if (parameter.isKindOf(VisualModel!NodePattern)) {
		return pattern.nodes.includes(parameter);
	} else if (parameter.isKindOf(VisualModel!AttributePattern)) {
		return pattern.nodes.collect(n| n.attributes).exists(attrList | attrList.includes(parameter));
	} else {
		assert(false, "Unexpected kind of parameter in parameterBelongsToPattern");
	}
}

operation collectAllConditionParameters(parameterRefs) {
	
	/*
	Fetches the set of all parameter (node or attribute) used in the calculation.
	*/
	var result = new Bag;
	
	for (parameterRef in parameterRefs) {
		var parameter = parameterRef.parameter;
		if (parameter.isKindOf(VisualModel!ExternalCalculationCall)) {
			result.addAll(collectAllConditionParameters(parameter.parameters));
		} else if (parameter.isKindOf(VisualModel!NodePattern)) {
			result.add(parameter);
		} else if (parameter.isKindOf(VisualModel!AttributePattern)) {
			result.add(parameter);
		} else {
			assert(false, "Unexpected kind of parameter in collectAllConditionParameters");
		}
	}
	
	return result;
}

operation getOperandFromPattern(operator, pattern) {
	return operator.operands.selectOne(operand | operand.pattern == pattern);
}


operation computeConditionSelectivityDenominator(sameCondition) {
	return max(computeConditionSelectivityDenominatorSourcePattern(sameCondition), computeConditionSelectivityDenominatorTargetPattern(sameCondition));
}

operation computeConditionSelectivityDenominatorSourcePattern(sameCondition) {
	var nodePattern = sameCondition.source;
	return nodePattern.expectedNumberOfDistinctValues;
}

operation computeConditionSelectivityDenominatorTargetPattern(sameCondition) {
	var nodePattern = sameCondition.target;
	return nodePattern.expectedNumberOfDistinctValues;
}

operation generateRandomIndexes(operator: VisualModel!Operator){
	var index = 1;
	
	for (operand in operator.operands){
		operand.index = index;
		index = index + 1;
	}
}


operation VisualModel!Operator hasOnlyOneOperand(){
	return self.operands.size() == 1;
}

operation VisualModel!Operator hasTwoOperands(){
	return self.operands.size() == 2;
}

operation VisualModel!Operator hasNoOperands(){
	return self.operands.isEmpty();
}

operation assert(condition, message) {
	if (not condition) {
		throw "Assertion error: " + message;
	}
}



operation getHashMapNodeInPatternField(node,pattern){
	return node.id.firstToLowerCase() + "In" + pattern.id.firstToUpperCase() + "Hash";
}


operation getAllInputPatternsSet() {
	var results = new Set;
	for (externalInputOperator in getAllExternalInputOperators()) {
		results.addAll(getPatternSucessorsFromOperator(externalInputOperator));
	}
	
	return results;
}

/*
	Returns nodes that are to be joined in some natural join operation.
*/
operation getJoinableNodes(nodes) {
	return nodes.select(n | isJoinableNode(n));
}

operation isJoinableNode(node) {
	return node.sameOut.exists(sameRelation | IsJoinableNodeInRelation(node, sameRelation))
			or node.sameIn.exists(sameRelation | IsJoinableNodeInRelation(node, sameRelation));
}

operation getOperatorContainingSameRelation(operators, sameRestriction) {
	return operators.select(operator | hasSourceInSomePatternSameRestriction(sameRestriction, getIncomingPatternsSet(operator)) and hasTargetInSomePatternSameRestriction(sameRestriction, getIncomingPatternsSet(operator)));
}

operation IsJoinableNodeInRelation(node, sameRelation) {
/*
An operator is joinable if there is at least one operation in which the pattern's node
is treated as a secondary operand.
*/
	var operatorsContainingSameRelation = getOperatorContainingSameRelation(node.pattern.outgoingOperands.collect(operand | operand.operator), sameRelation);
	
	var pattern = node.pattern;
	
	for (operator in operatorsContainingSameRelation) {
		assert(operator.operands.size==2, "incorrect operatorsContainingSameRelation.");
		var op1 = null;
		var op2 = null;
		
		if (operator.operands.first.pattern == pattern) {
			op1 = operator.operands.first;
			op2 = operator.operands.last;
		} else if (operator.operands.last.pattern == pattern) {
			op2 = operator.operands.first;
			op1 = operator.operands.last;
		}
		
		if (op1.index > op2.index) {
			return true;
		}
	}
	
	return false;
}


operation getAllOutputPatternsSet() {
	var results = new Set;
	for (externalOutputOperator in getAllExternalOutputOperators()) {
		results.addAll(getPatternPredecessorsFromOperator(externalOutputOperator));
	}
	
	return results;
}

operation getArrayListPatternField(pattern) {
	return pattern.id.firstToLowerCase() + "Array";
}

operation getIntCounterField(pattern,operator){
	return "newCounter" + pattern.id.firstToUpperCase() + operator.id.firstToUpperCase();
}

operation getOperandCounterField(operand){
	return "operand" + operand.pattern.id.firstToUpperCase() + operand.operator.id.firstToUpperCase() + "Counter";
}

operation getResultsCounterField(result){
	return "result" + result.operator.id.firstToUpperCase() + result.pattern.id.firstToUpperCase() + "Counter";
}

operation getHashSetPatternField(pattern){
	return pattern.id.firstToLowerCase() + "Set";
}

operation getOperatorMethodName(operator){
	return "executeOperator" + operator.id.firstToUpperCase();
}



operation selectNodeInPattern(node1, node2, pattern) {
	if (pattern.nodes.includes(node1)) {
		return node1;
	} else if (pattern.nodes.includes(node2))  {
		return node2;
	} else {
		throw "Unable to choose!";
	}
}



operation isAnyResult(result){
	return result.isKindOf(CoreModel!AnyResult);
}

operation isSomeResult(result){
	return result.isKindOf(CoreModel!SomeResult);
}



operation attributeIsDerived(at) {
	if (isDerivedByExternalAttributeCall(at)) {
		return true;
	}
	return false;
}

operation isDerivedByExternalAttributeCall(attribute) {
	if (attribute.attributeExternalCalculationCall <> null) {
		return true;
	}
	return false;
}



operation getAllAttributeParameters(parameterRefs) {
	/*
	Fetches the set of all attribute refs used in the calculation so that their existence can be verified prior to the calculation execution.
	*/
	var result = new Bag;
	
	for (parameterRef in parameterRefs) {
		if (parameterRef.isKindOf(CoreModel!ExternalAttributeCalculationCallParameter)) {
			result.addAll(getAttributeParameter(parameterRef.parameter));
		} else if (parameterRef.isKindOf(CoreModel!ExternalCalculationCallParameter)) {
			result.addAll(getAttributeParameter(parameterRef.parameter));
		} else if (parameterRef.isKindOf(CoreModel!ExternalConditionCallParameter)) {
			result.addAll(getAttributeParameter(parameterRef.parameter));
		} else {
			("Error: parameterRef: " + parameterRef).println();
			throw "Unexpected kind of parameterRef";
		}
	}
	
	return result;
}

operation getAttributeParameter(parameter) {
	var result = new Bag;
	if (parameter.isKindOf(CoreModel!NodePattern)) {
		// do nothing
	} else if (parameter.isKindOf(CoreModel!AttributePattern)) {
		result.add(parameter);
	} else if (parameter.isKindOf(CoreModel!ExternalCalculationCall)) {
		result.addAll(getAllAttributeParameters(parameter.parameters));
	} else {
		throw "Not implemented yet";
	}
	
	return result;
}


operation getParameterWithIndex(parameters, index) {
	return parameters.selectOne(param | param.index == index);
}



operation getAllNewNodePatterns(sourcePattern, targetPattern){
	return targetPattern.nodes.select(node: CoreModel!NodePattern | isNewNodePattern(node, sourcePattern));
}

operation isNewNodePattern(node, sourcePattern){
	return not hasAKeepRelationInSourcePattern(node, sourcePattern);
}

operation hasAKeepRelationInSourcePattern(node, sourcePattern){
	return sourcePattern.nodes.exists(sourceNode: CoreModel!NodePattern | hasAKeepRelation(sourceNode, node));
}

operation hasAKeepRelation(sourceNode, targetNode){
	return sourceNode.keepOut.exists(relation:CoreModel!Keep | relation.target = targetNode);
}


operation getCorrespondingNode(node, pattern) {
	return node.keepIn.selectOne(rel : CoreModel!Keep | patternContains(pattern, rel.source)).source;
}

operation patternContains(pattern, node) {
	return pattern.nodes.includes(node);
}

operation getAllKeepNodePatterns(sourcePattern, targetPattern){
	return targetPattern.nodes.select(node: CoreModel!NodePattern | isKeepNodePattern(node, sourcePattern));
}

operation isKeepNodePattern(node, sourcePattern){
	return hasAKeepRelationInSourcePattern(node, sourcePattern);
}

operation isAnyOperand(operand){
	return operand.isKindOf(CoreModel!AnyOperand);
}

operation isSomeOperand(operand){
	return operand.isKindOf(CoreModel!SomeOperand);
}

operation isAntiOperand(operand){
	return operand.isKindOf(CoreModel!AntiOperand);
}

operation isOptionalOperand(operand){
	return operand.isKindOf(CoreModel!OptionalOperand);
}

operation isOnlyOneOperand(operand1, operand2){
	return operand1 <> null and operand2 = null;
}

operation isDoubleOperand(operand1, operand2){
	return operand1 <> null and operand2 <> null;
}



operation getFirstOperand(operator){
	if (operator.operands.size() = 1) {
		return operator.operands.first;
	} else if (operator.operands.size() = 2) {
		if (operator.operands.first.index <= operator.operands.last.index) {
			return operator.operands.first;
		}else {
			return operator.operands.last;
		}
	} else {
		throw ("Unexpected number of operands in " + operator);
	}
}

operation getSecondOperand(operator){
	if (operator.operands.size() = 1) {
		return null;
	} else if (operator.operands.size() = 2) {
		if (operator.operands.first.index <= operator.operands.last.index) {
			return operator.operands.last;
		}else {
			return operator.operands.first;
		}
	} else {
		throw ("Unexpected number of operands in " + operator);
	}
}

operation hasJoinConditions(operator, operand1, operand2){
	if (operator.isKindOf(CoreModel!Combinator)) {
		return getRestrictions(operator).exists(same : CoreModel!Same | isRestrictionWithinPatterns(same, operand1.pattern, operand2.pattern));
	/*} else if (operator.isKindOf(CoreModel!Union)) {
		return getRestrictions(operator).exists(same : CoreModel!Same | isRestrictionWithinPatterns(same, operand1.pattern, operand2.pattern));
	*/} else {
		throw "Unexpected operator found: " + operator;
	}
}

operation selectJoinCondition(operator, operand1, operand2) {
	var restriction = selectMostRestrictiveJoinCondition(operator);
	
	assert(isRestrictionWithinPatterns(restriction, operand1.pattern, operand2.pattern), "Invalid restriction found in selectJoinCondition()");
	
	return restriction;
}

operation getRemainingConditions(operator, operand1, operand2, joinCondition) {
	if (joinCondition <> null) {
		return getRestrictions(operator).select(restriction : CoreModel!Restriction | restriction<>joinCondition and isRestrictionWithinPatterns(restriction, operand1.pattern, operand2.pattern));
	} else {
		return getRestrictions(operator).select(restriction : CoreModel!Restriction | isRestrictionWithinPatterns(restriction, operand1.pattern, operand2.pattern));
	}
}

operation isRestrictionWithinPatterns(restriction, pattern1, pattern2){
	return (pattern1.nodes.includes(restriction.source) and pattern2.nodes.includes(restriction.target)) or (pattern2.nodes.includes(restriction.source) and pattern1.nodes.includes(restriction.target));
}

operation getPatternHasChangedFlag(pattern) {
	return "pattern" + pattern.id.firstToUpperCase() + "HasChanged";
}



operation getNextOperators(operatorIterator) {
	if (operatorIterator.flowOut == null) {
		return new Bag;
	}
	
	if (operatorIterator.flowOut.isEmpty()) {
		return new Bag;
	}
	
	if (operatorIterator.flowOut.select(rule | rule.isKindOf(VisualModel!NextDerived)).isEmpty()) {
		throw "Interruption of execution flow in operator " + operatorIterator;
	}
	
	/* Com ciclos ja pode haver ambiguidades
	if (operatorIterator.flowOut.select(rule | rule.isKindOf(VisualModel!NextDerived)).size()>1) {
		throw "Ambiguity in execution flow in operator " + operatorIterator;
	}
	*/
	
	return operatorIterator.flowOut.select(rule | rule.isKindOf(VisualModel!NextDerived)).collect(rule | rule.target);
}

operation hasMoreOperatorSucessors(operatorIterator) {
	var nextOperators = getNextOperators(operatorIterator);
	
	return nextOperators <> null and (not nextOperators.isEmpty());
}

operation getFirstOperatorToBeExecuted() {
	var possibleResults = new Set;
	for (operator in VisualModel!Operator.all) {
		if (operator.flowIn == null) {
			possibleResults.add(operator);
		} else if (operator.flowIn.isEmpty()) {
			possibleResults.add(operator);
		}
	}
	
	if (possibleResults.isEmpty()) {
		throw "No execution plan found!";
	}
	
	if (possibleResults.size() > 1) {
		throw "Ambiguity in execution plan found!";
	}
	
	return possibleResults.first;
}


operation thereIsAPathBetween(startOp, endOp) {
	("Calculating path between: " + startOp + " and " + endOp).println();
	var nextOperators = getNextOperators(startOp);
	if (nextOperators.isEmpty()) {
		return false;
	}
	if (nextOperators.size() <> 1) {
		throw "Cycle not supported";
	}
	var operatorIterator = nextOperators.first;
	
	while (operatorIterator <> endOp) {
		nextOperators = getNextOperators(operatorIterator);
		if (nextOperators.size() == 0) {
			return false;
		}
		if (nextOperators.size() <> 1) {
			throw "Cycle not supported";
		}
		operatorIterator = nextOperators.first;
	}
	
	// operatorIterator == endOp
	return true;
}


operation isAtomic(pattern){
	return isSingleNodePattern(pattern) or isSingleEdgePattern(pattern);
}

operation isSingleNodePattern(pattern){
	return pattern.nodes.size()==1 and
			pattern.edges.size()==0;
}

operation isSingleEdgePattern(pattern){
	return pattern.edges.size() == 1 and
			(pattern.nodes.size() == 1 or pattern.nodes.size() == 2);
}

operation getCombinatorsBetweenSourcePatternAndTargetPattern(sourcePat, targetPat){
	return CoreModel!Combinator.all
			.select(op|
				op.operands.collect(operand | operand.pattern)
					.includes(sourcePat) and
				op.results.collect(result | result.pattern)
					.includes(targetPat));
}

operation getProjectionCombinatorsBetweenSourcePatternAndTargetPattern(sourcePat, targetPat){
	return getCombinatorsBetweenSourcePatternAndTargetPattern(sourcePat, targetPat)
			.reject(op | op.operands.size()>1 or op.results.size()>1)
			.reject(op | op.conditions.size()>1 or op.actions.size()>1);
}

operation isNodeProjected(pattern, node){
	
		// check if there is already an atomic pattern 
		// for this node connected to the output operator
		var candidateAtomicPatterns = 
			getCandidateAtomicPatternDecomposeFromNode(pattern, node);
		
		// check if there is a flow of elements from the current pattern 
		// to at least one of the patterns in the candidate patterns list.
		var foundOne = false;
		
		for (candidatePattern in candidateAtomicPatterns) { 
			var operatorsInCommon = 
				getProjectionCombinatorsBetweenSourcePatternAndTargetPattern(pattern, candidatePattern);
			
			if (not operatorsInCommon.isEmpty()){
				var keepRestrictions = 
					findKeepRestrictionsBetweenNodes(node, candidatePattern.nodes.first);
				if (keepRestrictions.size() > 0){
					
					if (keepRestrictions.size() > 1){
						throw "Redundant keep restriction found between node "+
							node.name + " in pattern " + pattern.id 
							+ " and the node in pattern " + candidatePattern.id;
					}
				
					// now we just need to make sure that the source of the 
					// keep is the node of the pattern.
					if (keepRestrictions.first.source == node){
						foundOne = true;
					}
				}
			}
		}
		
		return foundOne;
}

operation isEdgeProjected(pattern, edge){
	("Checking if edge " + edge.name + " of pattern " + 
			pattern.id + " is projected...").println();
	
	// check if there is already an atomic pattern 
	// for this edge connected to the output operator
	var candidateAtomicPatterns = getCandidateAtomicPatternDecomposeFromEdge(pattern, edge);
	
	("Number of candidate atomic patterns for edge " + edge.name + " of pattern: " + 
			candidateAtomicPatterns.size()).println();
	
	// check if there is a flow of elements from the current pattern 
	// to at least one of the patterns in the candidate patterns list.
	var foundOne = false;
	
	for (candidatePattern in candidateAtomicPatterns) { 
		var operatorsInCommon = 
			getProjectionCombinatorsBetweenSourcePatternAndTargetPattern(pattern, candidatePattern);
		
		("Operators in common between pattern " + pattern.id + " and pattern " + 
			candidatePattern.id + ": " + 
			operatorsInCommon.collect(op | op.id)).println();
	
		if (not operatorsInCommon.isEmpty()){
			
			var keepRestrictionsBetweenSourceNodes = 
				findKeepRestrictionsBetweenNodes(edge.source, candidatePattern.edges.first.source);
				
			var keepRestrictionsBetweenTargetNodes = 
				findKeepRestrictionsBetweenNodes(edge.target, candidatePattern.edges.first.target);
			
			if ((not keepRestrictionsBetweenSourceNodes.isEmpty())
				and (not keepRestrictionsBetweenTargetNodes.isEmpty())){
				if (keepRestrictionsBetweenSourceNodes.size() <> 1 and 
					keepRestrictionsBetweenTargetNodes.size() <> 1){
						throw "Strange redundance in Keep restrictions found.";
				}	
				foundOne = true;
			}
		}
	}
	
	("Is edge " + edge.name + " of pattern " + 
			pattern.id + " projected? " + foundOne).println();
	
	return foundOne;
	
}

operation isProjected(pattern){
	// to be Projected means that every atomic pattern in this apply 
	//   pattern was already Projected.
	
	// Iterate all atomic patterns
	// there will be 1 per each node and 1 per each edge.
	for (node in pattern.nodes) {
		if (not isNodeProjected(pattern,node)){
			return false;
		}
	}
	
	// now do the same thing for edges
	for (edge in pattern.edges) {
		if (not isEdgeProjected(pattern, edge)){
			return false;
		}
	}
	
	// if no node or edge left to decompose was found, it means this pattern is completely Projected.
	
	return true;
}


operation nodeIsEqual(node1, node2) {
	return node1.name == node2.name; // TODO later we might need to check the attributes...
}

operation edgeIsEqual(edge1, edge2) {
	return (edge1.name == edge2.name) and nodeIsEqual(edge1.source, edge2.source) and nodeIsEqual(edge1.target, edge2.target) ;
}

operation getCandidateAtomicPatternDecomposeFromNode(patternToBeProjected, node){
	return getAllOutputPatternsSet()
				.select(pattern|isSingleNodePattern(pattern) and
					nodeIsEqual(pattern.nodes.first, node) and
					getOperatorSucessorsFromPattern(pattern).size()==1 and // ensures no algebraic loops will be formed
					(not getOperatorPredecessorsFromPattern(pattern)
						.exists(op | op.operands.size() > 1 and  // ensures no ambiguity will result when projecting to this pattern.
										getPatternPredecessorsFromOperator(op).includes(patternToBeProjected))));
}

operation getCandidateAtomicPatternDecomposeFromEdge(patternToBeProjected, edge){
	return getAllOutputPatternsSet()
				.select(pattern|isSingleEdgePattern(pattern) 
					and edgeIsEqual(pattern.edges.first , edge) and
					getOperatorSucessorsFromPattern(pattern).size()==1 and // ensures no algebraic loops will be formed
					(not getOperatorPredecessorsFromPattern(pattern)
						.exists(op | op.operands.size() > 1 and  // ensures no ambiguity will result when projecting to this pattern.
										getPatternPredecessorsFromOperator(op).includes(patternToBeProjected))));
}

operation findKeepRestrictionsBetweenNodes(sourceNode, targetNode){
	return CoreModel!Keep.all.select(keepRestriction | 
		keepRestriction.source == sourceNode and 
		keepRestriction.target == targetNode);
}

operation sameAffectsOperator(same, op){
	var operatorOperandsNodes = op.operands
								.collect(operand | operand.pattern.nodes)
								.flatten();
	return operatorOperandsNodes.includes(same.source)
			and 
			operatorOperandsNodes.includes(same.target);
}

operation findAllImplicitOperators(trnetmodel){
	return trnetmodel.operators
						.select(op|isDecomposableOperator(op));
}

operation isDecomposableOperator(op){
	return isInternalOperator(op) and op.operands.size()>2;
}
























